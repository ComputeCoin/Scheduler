\documentclass{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{nomencl}
\makenomenclature

% Theorems
\theoremstyle{definition}

\newtheorem{definition}{Definition}[section]
\newtheorem{proposition}{Proposition}[section]

\theoremstyle{remark}

\newtheorem*{remark}{Remark}
\newtheorem*{theorem}{Theorem}

% Commands
\newcommand{\func}[3]{#1:#2\rightarrow#3}
\newcommand{\reqfunc}[2]{#1:#2\rightarrow\mathbb{B}}
\newcommand{\reqop}[2]{\mathbf{Req}_{#1}(#2)}

\newcommand{\path}[2]{\mathbf{Path}^{#2}_{#1}}
\newcommand{\pathall}[1]{\mathbf{Path}_{#1}}
\newcommand{\cyclepath}[1]{\mathbf{Cycle}_{#1}}

\newcommand{\labeledarrow}[1]{\stackrel{#1}{\rightarrow}}

\newcommand{\addpic}[1]{\includegraphics[width=1.0\textwidth]{#1}}

\newcommand{\setbuild}[3]
{
	\{\hspace{0.05in} 
	#1 \in #2 \hspace{0.05in} 
	| \hspace{0.05in}#3\hspace{0.05in}
	\}	
}

% Preamble
\title{Scala Job Scheduler}
\date{February 2018}

% --------------------------------------------------------------------------
\begin{document}
	
	% Title page
	\pagenumbering{gobble}
	\maketitle
	
	% Table of contents
	\newpage
	\tableofcontents
	
	% Begin main document
	\newpage
	\pagenumbering{arabic}
	
	\section{Introduction}

	
	\indent
	
	The aim of this project is to design an optimal scheduling algorithm for a scalable computing cloud, where
 computing resources are dynamically allocated to meet the demands of an inhomogeneous set of consumers. Resources
 are not uniformly distributed, geographically or otherwise, as the nodes comprising the cloud are of variable type
 and processing power. Clients will submit job specifications (indicating the number and type of cores, ideal
 network topology, required run time, etc.) to the scheduler, which should designate a time to run and a cluster of
 nodes that adheres to the specification. The algorithm should maximize throughput (efficient use of resources)
 while maintaining fairness, with wait times minimal and consistent between jobs that place similar demands on the
 system.
	
	In order to build an algorithm capable of operating on a complex, heterogeneous system of resources and consumers,
 we must consider the process from an abstract yet granular point of view. In an attempt to do so we have defined
 the system in terms of simple mathematical objects, and constructed an algebra over those objects to describe
 their interaction. By decomposing the scheduling process into its constituent parts, we were able to describe
 each component of the process in terms of this algebra and thus devise a mathematical model for the process as a
 whole. 
	
	Due to the difficulty of processing such a dynamic, diverse system (given the sheer number of factors to account
 for), we elected to confront the problem with a reinforcement learning algorithm built on the aforementioned model.
 The algorithm is highly dependent on the system's partitioning into measurable (numerically describable)
 components, and typifying these components for efficient processing - thus the focus on separability and producing
 quantifiable descriptors of the system. What follows is a detailed specification of the resultant scheduling
 paradigm: first of the environment and scheduling process, component by component, and then the construction of
 the reinforcement model from those components.
	

	\subsection{General Process}
	
<<<<<<< HEAD
	\addpic{figures/Intro-General.jpg}	
=======
	\addpic{./figures/Intro1.jpg}	
>>>>>>> 72f150dad2174a44130e76e19219862709c0d79f
	
	\addpic{figures/all-process.jpg}
	
	\addpic{figures/Macro-graph.png} 
	
<<<<<<< HEAD
	
	Upon submission by user, a consumer (job) enters the scheduling process with its specifications. It leaves the scheduling process by starting consuming (running on) assigned resources. Once finished, the consumer gives feedback to the scheduler for further training improvement.
	
	Example: a job is submitted with specifications such as arrival time, maximum run time, required number of nodes or cores, memory size, CPU/GPU, etc. After it finishes running, it gives feedback, such as wait time, actual run time, user reward, etc, to the scheduler.
	
	\addpic{figures/Intro-Scheduler.jpg}
=======
	\addpic{./figures/Intro2.jpg}
>>>>>>> 72f150dad2174a44130e76e19219862709c0d79f
	
	The scheduler first takes in the consumer specifications and inspects the current resource space. Then both the specifications and resource states are collected by the training module. During the reinforcement training, the training module and resource space are constantly being updated, while resources are being assigned or released and consumers entering or leaving the scheduling process.
	

	\subsection{Consumer}
	
	
	\subsection{Scheduling Process}
	
	
<<<<<<< HEAD
	\addpic{figures/Training-Main-Process.jpg}
=======
	\addpic{./figures/Training2.jpg}
>>>>>>> 72f150dad2174a44130e76e19219862709c0d79f
	
	
	a. Pre-Training
	
<<<<<<< HEAD
	\addpic{figures/Pre-Train.jpg}
	
	b. Nerual Network
=======
	\addpic{./figures/Pre-Train.jpg}
>>>>>>> 72f150dad2174a44130e76e19219862709c0d79f

	\addpic{figures/Neural-Network.jpeg}
	
	c. Policy Generator
	
	\addpic{figures/Policy-Generator.png}
	
	Bayesian Hierarchical Clustering
	
	d. Bins
	
	e. Joint Actions
	
<<<<<<< HEAD
	\addpic{figures/Joint-action.jpg}
=======
	\addpic{./figures/Joint-action.jpg}
>>>>>>> 72f150dad2174a44130e76e19219862709c0d79f
	
	There are three agent actions: catch, wait and release. An agent can either catch unoccupied resources to assign to a consumer, make a consumer wait for a certain amount of time, or release the resources occupied by a consumer. Based on their corresponding policies, multiple agents can have different actions on one consumer. Then these actions will jointly apply to this consumer in a time order.
		
	4.
	
	\newpage
	
	\part{Consumers, Requirements and Specifications}
	
	\section{Consumer}
	
		\begin{definition}
			A \emph{consumer}, $c$, is a triple $(k, \phi, t)$, where $k \in \mathbb{N}$, $\phi$ is a specification, and $t \in \mathbb{R}^{+}$. The consumer $C$ is the subset of consumer $c$ which defined such that:
			\[
			c = (\phi , \sigma_m)
			\]
			\[
			C = 2^{\phi}*[0,\sigma_m)
			\]
		\end{definition}
		
		\begin{definition}
			Let \emph{service} $v$ be the available resource can be provide which related with a subset of resource $R'$ and a boolean variable $\beta$ can be defined such that:
			\[
			v := (R', \beta)
			\]
			\[
			V = 2^{R}*{\ss}
			\]
		\end{definition}
	
	\section{Requirements}
	
		\begin{definition}
			A \emph{requirement} is a function $\reqfunc{\rho}{X}$, where $X$ is a set and $\mathbb{B} = \{0,1\}$. The set $X$ is referred to as the required set of $\rho$.
		\end{definition}
		
		\begin{definition}
			A requirement $\rho$ is said to be \emph{separable} if and only if it may be written as $\rho(x) = \prod_{i \in I}{\rho_{i}(x)}$, where $\forall i \in I$, $\rho_{i}(x)$ is a requirement with required set $X$.
		\end{definition}
		
		\begin{definition}
			A \emph{requirement operator} is a mapping, $\mathbf{Req}: \mathbf{Set} \rightarrow \mathbf{Set}$, such that: \[\reqop{\rho}{X} := \setbuild{x}	{X}{\rho(x) = 1}.\]
		\end{definition}
		
		\begin{proposition}
			Given a requirement $\rho = \rho_{1}\cdot\rho_{2}$, where $\rho_{1}$ and $\rho_{2}$ are requirements with required set X, then: 
			\[
			\reqop{\rho}{X}\stackrel{~}{=}\reqop{\rho_{1}}{X}\cdot\reqop{\rho_{2}}{X}
			\]
		\end{proposition}
		
		\begin{remark}
			The binary operation $\cdot$ between two requirements is the same as the symbol, $\wedge$, used in boolean
 algebra to represent the join, $and$, between two boolean statements. Likewise, $\cdot$ operating on two sets
 is the intersection operation $\cap$. 
		\end{remark}
		
		\begin{proof}
			The proof of this proposition is very straightforward. Let $X$ be a set and $\rho$ be a requirement with
 required set $X$. Then,
			
			\begin{eqnarray}
			\reqop{\rho}{X} & = & \setbuild{x}{X}{\rho(x) = 1}\\ 
			& = & \setbuild{x}{X}{\rho_{1}(x)\cdot\rho_{2}(x) = 1}\\ 
			& = & \setbuild{x}{X}{\rho_{1}(x) = 1 \mathbin{and} \rho_{2}(x) = 1}\\ 
			& = & \setbuild{x}{X}{\rho_{1}(x) = 1}\cdot\setbuild{x}{X}{\rho_{2}(x) = 1}\\
			& = & \reqop{\rho_{1}}{X}\cdot\reqop{\rho_{2}}{X}
			\end{eqnarray}
		\end{proof}
	
	\section{Specifications}
	
		\begin{definition}
			A set, $X$, is said to be inspectable if and only if there exists a function,
 $\func{\psi}{X}{\prod_{i \in I}{X_{i}}}$, where $X \ne X_{i}, \forall i \in I$. This function is referred to as an
 \emph{inspection function} of $X$.
		\end{definition}
		
		\begin{remark}
			The inspection function may also be expressed as, $\psi(x) = (\psi_{i}(x))_{i \in I}.$
		\end{remark}
		
		\begin{definition}
			A \emph{specification} is a requirement, $\reqfunc{\phi}{X}$, such that the following conditions
			hold:
			
			\begin{enumerate}
				\item   The required set, $X$, is inspectable.
				
				\item   There exists a requirement, $\reqfunc{\varphi}{\prod_{i \in I}{X_{i}}}$,
				such that $\rho = \varphi \circ \psi$, where $\psi$ is an inspection function of $X$,
				with $X \ne X_{i}, \forall i \in I$. The requirement, $\varphi$, is referred to as an
				\emph{acceptance requirement} of X.
			\end{enumerate}
			
		\end{definition}
		
		\begin{theorem}
			Given a separable specification, $\phi$, with an acceptance requirement that is mutually independent,
			$\varphi(x_i)_{i \in I}$, then following isomorphism holds:
			
			\[
			\reqop{\phi}{X} = \prod_{i \in I}\reqop{\varphi_{i}}{X_{i}}
			\]
		\end{theorem}
	
	\newpage
	
	\part{Resources}
	
	\newpage
	
	\part{Scheduling Process}
	
	\section{Process Decomposition}
	
		\begin{definition}
			let $a$ represent the arriving process $a = (c, t_a)$. Then the assignment action A defined as:
			\[
			A = C * [0, \infty)
			\]
		\end{definition}
		
		\begin{definition}
			let $g$ represent the assignment process, $g = (c,\sigma_w, v)$. Then the assignment action G can be defined as:
			\[
			G = C*[0,\sigma_m)*V
			\]
		\end{definition}
		
		\begin{definition}
			let $d$ represent the departure process $d = (c, t_d)$, we also defined $\gamma(c) = min{\sigma_r,\sigma_m}.$ Then the
 departure action D defined as:
			\[
			D = C * [t_a, t_a + \sigma_w + \gamma(c)]
			\]
		\end{definition}
	
	\newpage
	
	\part{Reinforcement Model}
	
	\section{Policy Routing}
	
	\subsection{Policy Graph}
	
<<<<<<< HEAD
	\subsection{Consumer Classification}
	Using Bayesian hierarchical clustering, consumers are classified into a certain consumer type represented by a
    numeric label (e.g. 1, 2). After classification, the consumer then enters their specification parameters and
    consumer type into a policy advisor which then outputs policy parameters for a scheduling agent to use, for
    the duration of their search.
=======
<<<<<<< HEAD
		\begin{definition} 
			Let $G = (V, E, src, tgt)$ be a graph. A \emph{path of length n} in $G$, denoted $p \in$ $\path{G}{(n)}$, is a head-to-tail sequence:
			\[
			p = (v_{1}   \labeledarrow{a_{1}}   v_{2}   \labeledarrow{a_{2}}  \cdots   \labeledarrow{a_{n-2}}  v_{n-1}   \labeledarrow{a_{n-1}}   v_{n})
			\]
			
			The \emph{set of all paths on G} is defined such that: 
			
			\[
			\pathall{G} : = \bigsqcup_{n \in \mathbb{N}}{\path{G}{(n)}}
			\]
		\end{definition}
		
		\begin{definition}
			let $\pathall{G}(v)$ be the all path from v back to v.
			
			The \emph{set of all path on G} is defined such that:
			
			$\pathall{G}(s,t) = \pathall{G}(s,v)\sqcup \cyclepath{G}(v) \sqcup \pathall{G}(v,t)$.
			
			The $\cyclepath{G}$ is defined as that:
			
			$\cyclepath{G}(v) = \pathall{G}(v,v)$
		\end{definition}
>>>>>>> ad11d32cf6bbb82c3709311a38f4457dd25bef35
	
=======
	\section{Policy Advisor}
	The policy advisor is the mechanism in which consumers utilize to encode their specification into their
    representative scheduling agents. These agents then use the output given by the policy advisor corresponding
    to their class in order to parameterize their policy. Upon completing this stage, the scheduling agent
    then starts to collect the resources specified by the consumer. The

    \begin{definition}
        A \emph{policy advisor}, $\mathcal{P}(\gamma)$
    \end{definition}

	\addpic{./figures/Neural-Network.jpeg}
	
	\addpic{./figures/Policy.png}
>>>>>>> 72f150dad2174a44130e76e19219862709c0d79f
	\newpage    

	\part{Appendix}
	\section{Mathematical Symbols and Notation}
		\mbox{}
			\nomenclature{$c$}{a consumer with 3 parameters}
			\nomenclature{$C$}{a subset of consumers}
			\nomenclature{$v$}{}
			\nomenclature{$V$}
			\nomenclature{$\rho$}
			\nomenclature{reqop{\rho}{X}}
			\nomenclature{$a$}{An arriving process}
			\nomenclature{$A, G$}{Assignment actions}
			\nomenclature{$g$}{An assignment process}
			\nomenclature{$d$}{A departure process}
			\nomenclature{$D$}{A departure action}
	\printnomenclature
	\newpage
	
\end{document}
